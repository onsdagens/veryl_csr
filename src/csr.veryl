// csr, individual register

import CsrPkg::*;

module Csr #(
    param Addr     : CsrAddr = 0, // 12 bit address for the CSR
    param ImmOffset: u32     = 0, // offset for immediate field
    param ImmWidth : u32     = 5, // field width
) (
    i_csr_ena : input logic      ,
    i_csr_addr: input CsrAddr    ,
    i_32      : input logic  <32>,
    i_5       : input CsrImm     ,
    i_csr_op  : input CsrOp      ,

    i_reg_data : input  logic<32>,
    o_reg_w_ena: output logic    ,
    o_reg_data : output logic<32>,
) {
    var i_5_ext : logic<32>;
    var i_5_mask: logic<32>;

    always_comb {
        // o_addr  = Addr;
        i_5_ext  = (i_5 as u32 & {1'0 repeat 32 - ImmWidth, 1'1 repeat ImmWidth}) << ImmOffset;
        i_5_mask = ~({1'0 repeat 32 - ImmWidth, 1'1 repeat ImmWidth} << ImmOffset);
        if (i_csr_addr == Addr && i_csr_ena) {
            o_reg_w_ena = 1;
            case i_csr_op {
                CsrOp::ECALL : o_reg_data = 0;
                CsrOp::CSRRW : o_reg_data = i_32;
                CsrOp::CSRRS : o_reg_data = i_reg_data | i_32;
                CsrOp::CSRRC : o_reg_data = i_reg_data & ~i_32;
                CsrOp::CSRRWI: o_reg_data = (i_reg_data & i_5_mask) | i_5_ext;
                CsrOp::CSRRSI: o_reg_data = i_reg_data | i_5_ext;
                CsrOp::CSRRCI: o_reg_data = i_reg_data & ~i_5_ext;
                default      : o_reg_data = 0;
            }
        } else {
            o_reg_data  = 0;
            o_reg_w_ena = 0;
        }
    }
}
